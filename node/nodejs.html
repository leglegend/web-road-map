<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入浅出Node.js | 前端学习路线</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/web-road-map/logo.png">
    <meta name="description" content="持续学习，不断学习">
    
    <link rel="preload" href="/web-road-map/assets/css/0.styles.7357bd1b.css" as="style"><link rel="preload" href="/web-road-map/assets/js/app.13fb6d60.js" as="script"><link rel="preload" href="/web-road-map/assets/js/2.1225ca4c.js" as="script"><link rel="preload" href="/web-road-map/assets/js/25.6b939b36.js" as="script"><link rel="prefetch" href="/web-road-map/assets/js/10.12de4a8c.js"><link rel="prefetch" href="/web-road-map/assets/js/11.edbf6fbd.js"><link rel="prefetch" href="/web-road-map/assets/js/12.2033684f.js"><link rel="prefetch" href="/web-road-map/assets/js/13.8fcecd74.js"><link rel="prefetch" href="/web-road-map/assets/js/14.12d5edae.js"><link rel="prefetch" href="/web-road-map/assets/js/15.29a83edc.js"><link rel="prefetch" href="/web-road-map/assets/js/16.41b1eb54.js"><link rel="prefetch" href="/web-road-map/assets/js/17.bc1a0b98.js"><link rel="prefetch" href="/web-road-map/assets/js/18.ed7e7234.js"><link rel="prefetch" href="/web-road-map/assets/js/19.70e23482.js"><link rel="prefetch" href="/web-road-map/assets/js/20.f38e69fc.js"><link rel="prefetch" href="/web-road-map/assets/js/21.ae3a9747.js"><link rel="prefetch" href="/web-road-map/assets/js/22.3325cd4d.js"><link rel="prefetch" href="/web-road-map/assets/js/23.fcd884a4.js"><link rel="prefetch" href="/web-road-map/assets/js/24.43f49526.js"><link rel="prefetch" href="/web-road-map/assets/js/26.7f6156e2.js"><link rel="prefetch" href="/web-road-map/assets/js/27.0f87c827.js"><link rel="prefetch" href="/web-road-map/assets/js/28.a55ffa53.js"><link rel="prefetch" href="/web-road-map/assets/js/3.a04893e0.js"><link rel="prefetch" href="/web-road-map/assets/js/4.6e796031.js"><link rel="prefetch" href="/web-road-map/assets/js/5.60876111.js"><link rel="prefetch" href="/web-road-map/assets/js/6.e66cf383.js"><link rel="prefetch" href="/web-road-map/assets/js/7.ebbb911e.js"><link rel="prefetch" href="/web-road-map/assets/js/8.84dc4039.js"><link rel="prefetch" href="/web-road-map/assets/js/9.73b65006.js">
    <link rel="stylesheet" href="/web-road-map/assets/css/0.styles.7357bd1b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/web-road-map/" class="home-link router-link-active"><!----> <span class="site-name">前端学习路线</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web-road-map/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/web-road-map/guide/" class="nav-link">
  导航
</a></div><div class="nav-item"><a href="/web-road-map/node/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/web-road-map/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://github.com/leglegend/web-road-map" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web-road-map/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/web-road-map/guide/" class="nav-link">
  导航
</a></div><div class="nav-item"><a href="/web-road-map/node/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/web-road-map/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://github.com/leglegend/web-road-map" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/web-road-map/node/" aria-current="page" class="sidebar-link">笔记</a></li><li><a href="/web-road-map/node/js-advanced.html" class="sidebar-link">JavaScript高级程序设计</a></li><li><a href="/web-road-map/node/nodejs.html" aria-current="page" class="active sidebar-link">深入浅出Node.js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#一、node简介" class="sidebar-link">一、Node简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#node的特点" class="sidebar-link">Node的特点</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#node的应用场景" class="sidebar-link">Node的应用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#二、模块机制" class="sidebar-link">二、模块机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#commonjs规范" class="sidebar-link">CommonJS规范</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#node的模块实现" class="sidebar-link">Node的模块实现</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#核心模块" class="sidebar-link">核心模块</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#c-c-扩展模块" class="sidebar-link">C/C++扩展模块</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#包与npm" class="sidebar-link">包与npm</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#前后端共用模块" class="sidebar-link">前后端共用模块</a></li></ul></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#三、异步i-o" class="sidebar-link">三、异步I/O</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#node的异步i-o" class="sidebar-link">Node的异步I/O</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#非i-o的异步api" class="sidebar-link">非I/O的异步API</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#事件驱动与高性能服务器" class="sidebar-link">事件驱动与高性能服务器</a></li></ul></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#四、异步编程" class="sidebar-link">四、异步编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#函数式编程" class="sidebar-link">函数式编程</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#异步编程的优势与难点" class="sidebar-link">异步编程的优势与难点</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#异步编程解决方案" class="sidebar-link">异步编程解决方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#五、内存控制" class="sidebar-link">五、内存控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#v8的垃圾回收机制与内存限制" class="sidebar-link">V8的垃圾回收机制与内存限制</a></li><li class="sidebar-sub-header"><a href="/web-road-map/node/nodejs.html#内存泄漏" class="sidebar-link">内存泄漏</a></li></ul></li></ul></li><li><a href="/web-road-map/node/html.html" class="sidebar-link">MDN HTML教学</a></li><li><a href="/web-road-map/node/vue3.html" class="sidebar-link">Vue.js设计与实现</a></li><li><a href="/web-road-map/node/http.html" class="sidebar-link">图解HTTP</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="深入浅出node-js"><a href="#深入浅出node-js" class="header-anchor">#</a> 深入浅出Node.js</h1> <h2 id="一、node简介"><a href="#一、node简介" class="header-anchor">#</a> 一、Node简介</h2> <h3 id="node的特点"><a href="#node的特点" class="header-anchor">#</a> Node的特点</h3> <h4 id="异步i-o"><a href="#异步i-o" class="header-anchor">#</a> 异步I/O</h4> <p>类似去web中的发送请求，浏览器在发送完请求后，并不知道服务器会在何时给出响应。在Node中，异步I/O与次类似，以读取未见为例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'reda file'</span><span class="token punctuation">)</span>
<span class="token comment">// read file</span>
<span class="token comment">// done</span>
</code></pre></div><h4 id="事件与回调函数"><a href="#事件与回调函数" class="header-anchor">#</a> 事件与回调函数</h4> <p>以处理Ajax请求为例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
http
  <span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    request<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string-property property">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/plain'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World\n'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span>
</code></pre></div><p>通过事件监听请求，通过回调处理请求。</p> <h4 id="单线程"><a href="#单线程" class="header-anchor">#</a> 单线程</h4> <p>Node和浏览器中的Javascript一样，都是单线程的，这使得我们不需要过多的考虑状态同步问题，但单线程也有他的弱点，比如无法利用多核CPU、错误会引起整个应用退出、占用CPU导致无法异步调用I/O。<br>
浏览器中可以利用Worker创建工作者线程，Node中可以利用ChildProcess创建子进程。</p> <h4 id="跨平台"><a href="#跨平台" class="header-anchor">#</a> 跨平台</h4> <p>通过libuv实现跨平台。</p> <h3 id="node的应用场景"><a href="#node的应用场景" class="header-anchor">#</a> Node的应用场景</h3> <p>I/O密集型（异步I/O）<br>
是否不擅长CPU密集型业务？单线程容易阻塞
分布式应用</p> <h2 id="二、模块机制"><a href="#二、模块机制" class="header-anchor">#</a> 二、模块机制</h2> <h3 id="commonjs规范"><a href="#commonjs规范" class="header-anchor">#</a> CommonJS规范</h3> <ol><li>模块引用</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>模块定义
在Node中，一个文件就是一个模块，在模块中，还存在一个module对象，exports是module的属性。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
exports<span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>模块标识
模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以．、.．开头的相对路径，或者绝对路径。它可以没有文件名后缀．js。</li></ol> <h3 id="node的模块实现"><a href="#node的模块实现" class="header-anchor">#</a> Node的模块实现</h3> <p>在Node中引入模块，需要经历3个步骤：路径分析、文件定位、编译执行。Node种有两类模块，一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。<br>
核心模块在源码编译过程中就直接加载到内存中，而文件模块是在运行时加载的。<br>
Node对引入过的模块会进行缓存，无论什么模块，Node二次加载都会采用缓存优先。</p> <h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="header-anchor">#</a> 路径分析和文件定位</h4> <p>require()接收一个模块标识符，模块标识符在Node种有以下几类：</p> <ul><li>核心模块，如http、fs、path等。</li> <li>．或．．开始的相对路径文件模块。</li> <li>以/开始的绝对路径文件模块。</li> <li>非路径形式的文件模块，如自定义的connect模块。
require()方法会将路径转为真实路径。<br>
自定义模块会自身所在目录逐级向上查找node_modules目录，如果找到，就会加载该模块，比较慢。<br>
遇到没添加扩展名的文件，Node会按．js、.json、.node的次序补足扩展名，依次尝试，如果不是js文件，最好加上扩展名。<br>
require()没有找到对应的文件，会把目录当作一个包来处理，首先查找package.json文件，如果没有，会查找index文件。</li></ul> <h4 id="模块编译"><a href="#模块编译" class="header-anchor">#</a> 模块编译</h4> <p>在Node中，每个模块就是一个对象：</p> <div class="language-js extra-class"><pre class="language-js"><code>        <span class="token keyword">function</span> <span class="token function">Module</span><span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

          <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。<br>
Node对获取的JavaScript文件内容进行了头尾包装，一个正常的JavaScript文件会被包装成如下的样子：</p> <div class="language-js extra-class"><pre class="language-js"><code>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          exports<span class="token punctuation">.</span><span class="token function-variable function">area</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">radius</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> radius <span class="token operator">*</span> radius<span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>所以在每个js文件中都能访问到exports、module等变量和require方法。<br>
由于这里面exports是以形参的方式传入的，所以不能直接给exports复制，如果需要则要使用<code>module.exports</code>进行赋值。</p> <h3 id="核心模块"><a href="#核心模块" class="header-anchor">#</a> 核心模块</h3> <p>核心模块其实分为C/C++编写的和JavaScript编写的两部分，其中C/C++文件存放在Node项目的src目录下，JavaScript文件存放在lib目录下。</p> <h3 id="c-c-扩展模块"><a href="#c-c-扩展模块" class="header-anchor">#</a> C/C++扩展模块</h3> <p>V8是Node自身的动力来源之一。它自身由C++写成，可以实现JavaScript与C++的互相调用。</p> <h3 id="包与npm"><a href="#包与npm" class="header-anchor">#</a> 包与npm</h3> <h4 id="包结构"><a href="#包结构" class="header-anchor">#</a> 包结构</h4> <ul><li>package.json：包描述文件。</li> <li>bin：用于存放可执行二进制文件的目录。</li> <li>lib：用于存放JavaScript代码的目录。</li> <li>doc：用于存放文档的目录。</li> <li>test：用于存放单元测试用例的代码。</li></ul> <div class="language-json extra-class"><pre class="language-json"><code><span class="token comment">// package.json</span>
<span class="token punctuation">{</span>
    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 包名 规范定义它需要由小写的字母和数字组成，可以包含．、_和-，但不允许出现空格。</span>
    <span class="token property">&quot;description&quot;</span><span class="token operator">:</span> <span class="token string">&quot;a node package&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 包描述</span>
    <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 包版本</span>
    <span class="token property">&quot;keywords&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;package&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 包关键字</span>
    <span class="token property">&quot;maintainers&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;maintainer&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 包维护者列表。每个维护者由name、email和web这3个属性组成</span>
    <span class="token property">&quot;contributors&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 贡献者列表</span>
    <span class="token property">&quot;bugs&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 一个可以反馈bug的网页地址或邮件地址。</span>
    <span class="token property">&quot;licenses&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 许可证</span>
    <span class="token property">&quot;repository&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 代码仓库</span>
    <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 使用当前包所需要依赖的包列表。NPM会通过这个属性帮助自动加载依赖的包。</span>
    <span class="token property">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 一些模块只在开发时需要依赖。</span>
    <span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 脚本说明对象 </span>
    <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="npm常用功能"><a href="#npm常用功能" class="header-anchor">#</a> NPM常用功能</h4> <div class="language-js extra-class"><pre class="language-js"><code>npm <span class="token operator">-</span>v <span class="token comment">// 查看NPM版本</span>
npm <span class="token comment">// 查看npm帮助</span>
npm install express <span class="token comment">// 安装依赖包</span>
npm install express <span class="token operator">-</span>g <span class="token comment">// 全局安装依赖包</span>
npm install underscore <span class="token operator">--</span>registry<span class="token operator">=</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>url <span class="token comment">// 使用特定的registry安装依赖包</span>
npm config <span class="token keyword">set</span> registry http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>url <span class="token comment">// 修改默认源</span>
npm init <span class="token comment">// 初始化项目，生成package.json文件</span>
npm adduser <span class="token comment">// 注册账号</span>
npm publish <span class="token comment">// 发布包</span>
npm ls <span class="token comment">// 查看包列表</span>
</code></pre></div><h3 id="前后端共用模块"><a href="#前后端共用模块" class="header-anchor">#</a> 前后端共用模块</h3> <p>一些模块可以做到前后端公用。</p> <h2 id="三、异步i-o"><a href="#三、异步i-o" class="header-anchor">#</a> 三、异步I/O</h2> <p>异步I/O的提出是期望I/O的调用不再阻塞后续运算，将原有等待I/O完成的这段时间分配给其余需要的业务去执行。<br>
操作系统内核对于I/O只有两种方式：阻塞与非阻塞。阻塞I/O会等待I/O完成，非阻塞I/O会立即返回调用状态，为获取完整数据，需重复调用I/O来确认是否完成，这种重复调用判断叫做轮询。<br>
对于Node的异步I/O，实际上是把I/O放在了其他线程完成。我们把JavaScript运行的线程叫做主线程，通过部分线程进行阻塞或非阻塞I/O操作，完成后通过线程通信将数据返回主线程，这就实现了异步I/O。<br>
Windows和*nix平台都支持这种异步I/O操作，但是实现方式不同，Node提供了libuv作为抽象封装层，抹平了不同平台的差异。</p> <h3 id="node的异步i-o"><a href="#node的异步i-o" class="header-anchor">#</a> Node的异步I/O</h3> <p>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。<br>
除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）则是可以并行起来的。</p> <h3 id="非i-o的异步api"><a href="#非i-o的异步api" class="header-anchor">#</a> 非I/O的异步API</h3> <p>setTimeout()、setInterval()、setImmediate()和process.nextTick()是一些一些与I/O无关的异步API。<br>
调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。<br>
调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。<br>
setImmediate()优先级低于process.nextTick()。</p> <h3 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="header-anchor">#</a> 事件驱动与高性能服务器</h3> <p>集中典型的服务器模型：</p> <ul><li>同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。</li> <li>每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。</li> <li>每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。<br>
Node采用事件驱动，通过事件循环处理所有任务。</li></ul> <h2 id="四、异步编程"><a href="#四、异步编程" class="header-anchor">#</a> 四、异步编程</h2> <h3 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h3> <p>高阶函数：以函数作为参数或返回值的函数。<br>
通过指定部分参数来产生一个新的定制函数的形式就是偏函数。</p> <h3 id="异步编程的优势与难点"><a href="#异步编程的优势与难点" class="header-anchor">#</a> 异步编程的优势与难点</h3> <p>基于事件驱动的非阻塞异步I/O模型。<br>
try/catch语句不能捕获异步请求。</p> <h3 id="异步编程解决方案"><a href="#异步编程解决方案" class="header-anchor">#</a> 异步编程解决方案</h3> <ul><li>事件发布/订阅模式。</li> <li>Promise/Deferred模式。</li> <li>流程控制库。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>        <span class="token comment">// 订阅</span>
        emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;event1&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 只会触发一次</span>
        emitter<span class="token punctuation">.</span>once<span class="token string">&quot;event1&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 发布</span>
        emitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">,</span> <span class="token string">&quot;I am message! &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Promise现在ES6已经支持了。</p> <h2 id="五、内存控制"><a href="#五、内存控制" class="header-anchor">#</a> 五、内存控制</h2> <p>在浏览器不需要过多的关注垃圾回收机制，但是服务器接收所有用户的访问，需要严格控制内存使用。</p> <h3 id="v8的垃圾回收机制与内存限制"><a href="#v8的垃圾回收机制与内存限制" class="header-anchor">#</a> V8的垃圾回收机制与内存限制</h3> <p>Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB,32位系统下约为0.7GB）。<br>
当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。
可通过以下方式调整内存：</p> <div class="language- extra-class"><pre class="language-text"><code>        node --max-old-space-size=1700 test.js // 单位为MB
        // 或者
        node --max-new-space-size=1024 test.js // 单位为KB        
</code></pre></div><h3 id="内存泄漏"><a href="#内存泄漏" class="header-anchor">#</a> 内存泄漏</h3> <p>把内存当缓存是危险的，最好使用外部缓存，Redis。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/web-road-map/node/js-advanced.html" class="prev">
        JavaScript高级程序设计
      </a></span> <span class="next"><a href="/web-road-map/node/html.html">
        MDN HTML教学
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/web-road-map/assets/js/app.13fb6d60.js" defer></script><script src="/web-road-map/assets/js/2.1225ca4c.js" defer></script><script src="/web-road-map/assets/js/25.6b939b36.js" defer></script>
  </body>
</html>
